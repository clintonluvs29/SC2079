import math

def euclidean(p, q):
    return math.hypot(p[0] - q[0], p[1] - q[1])
#def dubins_distance

def nearest_neighbour_optimized(start, points):
    n = len(points)
    visited = [False] * n
    path = []

    v = start
    path.append(v)
    visited[v] = True

    for _ in range(n - 1):
        candidates = []

        # 1. Compute Euclidean distances (cheap)
        for w in range(n):
            if not visited[w]:
                e_dist = euclidean(points[v], points[w])
                candidates.append((e_dist, w))

        # 2. Sort by Euclidean distance
        candidates.sort(key=lambda x: x[0])

        best_dubins = float('inf')
        best_w = None

        # 3. Check in increasing Euclidean order
        for e_dist, w in candidates:
            # pruning condition
            if e_dist >= best_dubins:
                break

            d_dist = dubins_distance(v, w)  # expensive
            if d_dist < best_dubins:
                best_dubins = d_dist
                best_w = w

        path.append(best_w)
        visited[best_w] = True
        v = best_w

    return path

def swap(path, i, j):
    path[i], path[j] = path[j], path[i]

def path_length(path):
    total = 0.0
    for i in range(len(path) - 1):
        total += distance(path[i], path[i + 1])
    return total

def improve_path(path):
    best_length = path_length(path)

    for i in range(1, len(path) - 1):
        # swap adjacent vertices
        swap(path, i, i + 1)

        new_length = path_length(path)

        # undo swap if itâ€™s not better
        if new_length >= best_length:
            swap(path, i, i + 1)
        else:
            best_length = new_length

start = [0]
points = []
unimproved_path = nearest_neighbour_optimized(start, points)
path = improve_path(unimproved_path)
