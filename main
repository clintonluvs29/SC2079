import math

def mod2pi(theta):
    return theta - 2.0 * math.pi * math.floor(theta / (2.0 * math.pi))

def LSL(alpha, beta, d):
    tmp = d + math.sin(alpha) - math.sin(beta)
    p_sq = 2 + d*d - 2*math.cos(alpha - beta) + 2*d*(math.sin(alpha) - math.sin(beta))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    t = mod2pi(-alpha + math.atan2((math.cos(beta) - math.cos(alpha)), tmp))
    q = mod2pi(beta - math.atan2((math.cos(beta) - math.cos(alpha)), tmp))
    return t, p, q

def RSR(alpha, beta, d):
    tmp = d - math.sin(alpha) + math.sin(beta)
    p_sq = 2 + d*d - 2*math.cos(alpha - beta) + 2*d*(math.sin(beta) - math.sin(alpha))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    t = mod2pi(alpha - math.atan2((math.cos(alpha) - math.cos(beta)), tmp))
    q = mod2pi(-beta + math.atan2((math.cos(alpha) - math.cos(beta)), tmp))
    return t, p, q

def LSR(alpha, beta, d):
    p_sq = -2 + d*d + 2*math.cos(alpha - beta) + 2*d*(math.sin(alpha) + math.sin(beta))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    tmp = math.atan2(-math.cos(alpha) - math.cos(beta),
                     d + math.sin(alpha) + math.sin(beta))
    t = mod2pi(-alpha + tmp)
    q = mod2pi(-beta + tmp)
    return t, p, q

def RSL(alpha, beta, d):
    p_sq = -2 + d*d + 2*math.cos(alpha - beta) - 2*d*(math.sin(alpha) + math.sin(beta))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    tmp = math.atan2(math.cos(alpha) + math.cos(beta),
                     d - math.sin(alpha) - math.sin(beta))
    t = mod2pi(alpha - tmp)
    q = mod2pi(beta - tmp)
    return t, p, q

def RLR(alpha, beta, d):
    tmp = (6 - d*d + 2*math.cos(alpha - beta) +
           2*d*(math.sin(alpha) - math.sin(beta))) / 8
    if abs(tmp) > 1:
        return None
    p = mod2pi(2*math.pi - math.acos(tmp))
    t = mod2pi(alpha - math.atan2(math.cos(alpha) - math.cos(beta),
                                  d - math.sin(alpha) + math.sin(beta)) + p/2)
    q = mod2pi(alpha - beta - t + p)
    return t, p, q

def LRL(alpha, beta, d):
    tmp = (6 - d*d + 2*math.cos(alpha - beta) +
           2*d*(math.sin(beta) - math.sin(alpha))) / 8
    if abs(tmp) > 1:
        return None
    p = mod2pi(2*math.pi - math.acos(tmp))
    t = mod2pi(-alpha - math.atan2(math.cos(alpha) - math.cos(beta),
                                   d + math.sin(alpha) - math.sin(beta)) + p/2)
    q = mod2pi(beta - alpha - t + p)
    return t, p, q

def dubins_distance(q0, q1, R):
    """
    q0, q1 = (x, y, theta)
    R = minimum turning radius
    """
    dx = q1[0] - q0[0]
    dy = q1[1] - q0[1]
    D = math.hypot(dx, dy)
    d = D / R

    theta = math.atan2(dy, dx)
    alpha = mod2pi(q0[2] - theta)
    beta  = mod2pi(q1[2] - theta)

    path_fns = [LSL, RSR, LSR, RSL, RLR, LRL]
    lengths = []

    for fn in path_fns:
        path = fn(alpha, beta, d)
        if path is not None:
            t, p, q = path
            lengths.append(t + p + q)

    if not lengths:
        return None  # no feasible Dubins path

    return min(lengths) * R

def euclidean(p, q):
    return math.hypot(p[0] - q[0], p[1] - q[1])
#def dubins_distance

def nearest_neighbour_optimized(start, points, R):
    n = len(points)
    visited = [False] * n
    path = []

    v = start
    path.append(v)
    visited[v] = True

    for _ in range(n - 1):
        candidates = []

        # 1. Compute Euclidean distances (cheap)
        for w in range(n):
            if not visited[w]:
                e_dist = euclidean(points[v], points[w])
                candidates.append((e_dist, w))

        # 2. Sort by Euclidean distance
        candidates.sort(key=lambda x: x[0])

        best_dubins = float('inf')
        best_w = None

        # 3. Check in increasing Euclidean order
        for e_dist, w in candidates:
            # pruning condition
            if e_dist >= best_dubins:
                break

            d_dist = dubins_distance(v, w, R)  # expensive
            if d_dist < best_dubins:
                best_dubins = d_dist
                best_w = w

        path.append(best_w)
        visited[best_w] = True
        v = best_w

    return path

def swap(path, i, j):
    path[i], path[j] = path[j], path[i]

def path_length(path):
    total = 0.0
    for i in range(len(path) - 1):
        total += distance(path[i], path[i + 1])
    return total

def improve_path(path):
    best_length = path_length(path)

    for i in range(1, len(path) - 1):
        # swap adjacent vertices
        swap(path, i, i + 1)

        new_length = path_length(path)

        # undo swap if itâ€™s not better
        if new_length >= best_length:
            swap(path, i, i + 1)
        else:
            best_length = new_length

def dubins_shortest_path(q0, q1, R):
    dx = q1[0] - q0[0]
    dy = q1[1] - q0[1]
    D = math.hypot(dx, dy)
    d = D / R

    theta = math.atan2(dy, dx)
    alpha = mod2pi(q0[2] - theta)
    beta  = mod2pi(q1[2] - theta)

    candidates = {
        "LSL": LSL(alpha, beta, d),
        "RSR": RSR(alpha, beta, d),
        "LSR": LSR(alpha, beta, d),
        "RSL": RSL(alpha, beta, d),
        "RLR": RLR(alpha, beta, d),
        "LRL": LRL(alpha, beta, d),
    }

    best_type = None
    best_length = float("inf")
    best_segments = None

    for path_type, segs in candidates.items():
        if segs is None:
            continue
        length = sum(segs)
        if length < best_length:
            best_length = length
            best_type = path_type
            best_segments = segs

    return best_type, best_segments

def segments_to_commands(path_type, segments, R):
    commands = []
    types = list(path_type)  # e.g. ['L','S','L']

    for motion, length in zip(types, segments):
        if motion == "S":
            dist = length * R
            commands.append(("S", dist))
        else:
            arc = length * R
            commands.append((motion, arc))

    return commands

#example of how to run
"""
q0 = (0.0, 0.0, 0.0)
q1 = (5.0, 3.0, math.pi/2)
R = 1.0  # meters

path_type, segments = dubins_shortest_path(q0, q1, R)
commands = segments_to_commands(path_type, segments, R)

print("Dubins type:", path_type)
for cmd in commands:
    print(cmd)
"""

start = (0,0)
points = []
radius = 5
unimproved_path = nearest_neighbour_optimized(start, points, radius)
path = improve_path(unimproved_path)
