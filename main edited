import math

# --------------------- Constants --------------------- #
X_MIN, X_MAX = 0.0, 2000.0
Y_MIN, Y_MAX = 0.0, 2000.0
edge_cache = {}
# --------------------- Utility Functions --------------------- #
def mod2pi(theta):
    return theta - 2.0 * math.pi * math.floor(theta / (2.0 * math.pi))

def euclidean(p, q):
    return math.hypot(p[0] - q[0], p[1] - q[1])

def within_bounds(x, y):
    """Check if a point is within the defined boundaries"""
    return X_MIN <= x <= X_MAX and Y_MIN <= y <= Y_MAX

# --------------------- Dubins Path Types --------------------- #
def LSL(alpha, beta, d):
    tmp = d + math.sin(alpha) - math.sin(beta)
    p_sq = 2 + d*d - 2*math.cos(alpha - beta) + 2*d*(math.sin(alpha) - math.sin(beta))
    if p_sq < 0: return None
    p = math.sqrt(p_sq)
    t = mod2pi(-alpha + math.atan2(math.cos(beta) - math.cos(alpha), tmp))
    q = mod2pi(beta - math.atan2(math.cos(beta) - math.cos(alpha), tmp))
    return t, p, q

def RSR(alpha, beta, d):
    tmp = d - math.sin(alpha) + math.sin(beta)
    p_sq = 2 + d*d - 2*math.cos(alpha - beta) + 2*d*(math.sin(beta) - math.sin(alpha))
    if p_sq < 0: return None
    p = math.sqrt(p_sq)
    t = mod2pi(alpha - math.atan2(math.cos(alpha) - math.cos(beta), tmp))
    q = mod2pi(-beta + math.atan2(math.cos(alpha) - math.cos(beta), tmp))
    return t, p, q

def LSR(alpha, beta, d):
    p_sq = -2 + d*d + 2*math.cos(alpha - beta) + 2*d*(math.sin(alpha) + math.sin(beta))
    if p_sq < 0: return None
    p = math.sqrt(p_sq)
    tmp = math.atan2(-math.cos(alpha) - math.cos(beta), d + math.sin(alpha) + math.sin(beta))
    t = mod2pi(-alpha + tmp)
    q = mod2pi(-beta + tmp)
    return t, p, q

def RSL(alpha, beta, d):
    p_sq = -2 + d*d + 2*math.cos(alpha - beta) - 2*d*(math.sin(alpha) + math.sin(beta))
    if p_sq < 0: return None
    p = math.sqrt(p_sq)
    tmp = math.atan2(math.cos(alpha) + math.cos(beta), d - math.sin(alpha) - math.sin(beta))
    t = mod2pi(alpha - tmp)
    q = mod2pi(beta - tmp)
    return t, p, q

def RLR(alpha, beta, d):
    tmp = (6 - d*d + 2*math.cos(alpha - beta) + 2*d*(math.sin(alpha) - math.sin(beta))) / 8
    if abs(tmp) > 1: return None
    p = mod2pi(2*math.pi - math.acos(tmp))
    t = mod2pi(alpha - math.atan2(math.cos(alpha) - math.cos(beta), d - math.sin(alpha) + math.sin(beta)) + p/2)
    q = mod2pi(alpha - beta - t + p)
    return t, p, q

def LRL(alpha, beta, d):
    tmp = (6 - d*d + 2*math.cos(alpha - beta) + 2*d*(math.sin(beta) - math.sin(alpha))) / 8
    if abs(tmp) > 1: return None
    p = mod2pi(2*math.pi - math.acos(tmp))
    t = mod2pi(-alpha - math.atan2(math.cos(alpha) - math.cos(beta), d + math.sin(alpha) - math.sin(beta)) + p/2)
    q = mod2pi(beta - alpha - t + p)
    return t, p, q

# --------------------- Dubins Path Length --------------------- #
def dubins_shortest_path(q0, q1, R):
    dx = q1[0] - q0[0]
    dy = q1[1] - q0[1]
    D = math.hypot(dx, dy)
    d = D / R

    theta = math.atan2(dy, dx)
    alpha = mod2pi(q0[2] - theta)
    beta  = mod2pi(q1[2] - theta)

    candidates = {
        "LSL": LSL(alpha, beta, d),
        "RSR": RSR(alpha, beta, d),
        "LSR": LSR(alpha, beta, d),
        "RSL": RSL(alpha, beta, d),
        "RLR": RLR(alpha, beta, d),
        "LRL": LRL(alpha, beta, d),
    }

    best_type = None
    best_segments = None
    best_length = float("inf")

    for path_type, segs in candidates.items():
        if segs is None: continue
        length = sum(segs)
        if length < best_length:
            best_length = length
            best_type = path_type
            best_segments = segs

    return best_type, best_segments

def segments_to_commands(path_type, segments, R):
    commands = []

    for motion, length in zip(path_type, segments):
        dist = length * R  # arc length or straight distance

        if motion == "L":
            angle_rad = dist / R
            angle_deg = math.degrees(angle_rad)
            commands.append(("LEFT", angle_deg))

        elif motion == "R":
            angle_rad = dist / R
            angle_deg = math.degrees(angle_rad)
            commands.append(("RIGHT", angle_deg))

        elif motion == "S":
            commands.append(("FORWARD", dist))

    return commands

def sample_dubins_path_pose(q0, path_type, segments, R, step=5.0):
    x, y, theta = q0
    samples = [(x, y, theta)]

    for motion, seg in zip(path_type, segments):
        length = seg * R
        traveled = 0.0

        while traveled < length:
            ds = min(step, length - traveled)

            if motion == "S":
                x += ds * math.cos(theta)
                y += ds * math.sin(theta)

            elif motion == "L":
                dtheta = ds / R
                theta += dtheta
                x += R * (math.sin(theta) - math.sin(theta - dtheta))
                y -= R * (math.cos(theta) - math.cos(theta - dtheta))

            elif motion == "R":
                dtheta = ds / R
                theta -= dtheta
                x += R * (math.sin(theta) - math.sin(theta + dtheta))
                y -= R * (math.cos(theta) - math.cos(theta + dtheta))

            traveled += ds
            samples.append((x, y, theta))

    return samples

# --------------------- Obstacles --------------------- #
def build_obstacles(obstacle_points):
    obstacles = []
    for x, y, _ in obstacle_points:
        obstacles.append((x-150, x+150, y-150, y+150))
    return obstacles

def point_in_rect(x, y, rect):
    xmin, xmax, ymin, ymax = rect
    return xmin <= x <= xmax and ymin <= y <= ymax

def path_collides(points, obstacles):
    for x, y in points:
        for obs in obstacles:
            if point_in_rect(x, y, obs):
                return True
    return False

def path_out_of_bounds(points):
    """Check if any sampled point in the path is outside boundaries"""
    for x, y in points:
        if not within_bounds(x, y):
            return True
    return False

def dubins_path_valid(q0, q1, R, obstacles):
    """Check if Dubins path is collision-free AND within boundaries"""
    path_type, segments = dubins_shortest_path(q0, q1, R)
    if path_type is None:
        return None
    length = sum(segments) * R
    samples = sample_dubins_path(q0, path_type, segments, R)
    
    # Check both collisions and boundaries
    if path_collides(samples, obstacles):
        return None
    if path_out_of_bounds(samples):
        return None
    
    return path_type, segments, length

# --------------------- TSP Heuristics --------------------- #
def get_edge(i, j, goals, R, edge_cache):

    if (i, j) in edge_cache:
        return edge_cache[(i, j)]

    result = dubins_path_valid(goals[i], goals[j], R, OBSTACLES)

    edge_cache[(i, j)] = result
    return result

def nearest_neighbour_optimized(start, points, R): 
    n = len(points) 
    visited = [False] * n 
    path = [start]
    visited[start] = True
    v = start

    for _ in range(n - 1): 
        candidates = [(euclidean(points[v], points[w]), w) for w in range(n) if not visited[w]]
        candidates.sort(key=lambda x: x[0])
        best_dubins = float('inf')
        best_w = None

        for e_dist, w in candidates:
            if e_dist >= best_dubins: break
            edge = get_edge(v, w, points, R, edge_cache)
            if edge is None: continue
            d_dist = edge[2]
            if d_dist < best_dubins:
                best_dubins = d_dist
                best_w = w

        if best_w is None:
            raise RuntimeError(f"No valid Dubins edge from node {v} (collision or out of bounds)")

        path.append(best_w)
        visited[best_w] = True
        v = best_w
    return path

def swap(path, i, j):
    path[i], path[j] = path[j], path[i]

def path_length(path, points, R):
    total = 0.0
    for i in range(len(path)-1):
        edge = get_edge(path[i], path[i+1], points, R, edge_cache)
        if edge is None: return float("inf")
        total += edge[2]
    return total

def improve_path(path, points, R):
    best_length = path_length(path, points, R)
    for i in range(1, len(path)-1):
        swap(path, i, i+1)
        new_length = path_length(path, points, R)
        if new_length >= best_length:
            swap(path, i, i+1)
        else:
            best_length = new_length
    return path

# --------------------- Goal Generation --------------------- #
def points_to_goals(points):
    goals = []
    for x, y, direction in points:
        if direction == "N":
            goal = (x+50, y+250, -math.pi/2)
        elif direction == "S":
            goal = (x-50, y-250, math.pi/2)
        elif direction == "W":
            goal = (x-250, y+50, 0.0)
        elif direction == "E":
            goal = (x+250, y-50, math.pi)
        else:
            raise ValueError(f"Unknown direction: {direction}")
        goals.append(goal)
    return goals

# --------------------- Generate Full Dubins Commands --------------------- #
def full_dubins_commands(path, goals, R):
    commands_list = []

    for i in range(len(path) - 1):
        q0 = goals[path[i]]
        q1 = goals[path[i+1]]

        edge = dubins_path_valid(q0, q1, R, OBSTACLES)
        
        if edge is None:
            raise RuntimeError(f"No valid Dubins path between {q0} and {q1}")
            
        path_type, segments, _ = edge

        commands = segments_to_commands(path_type, segments, R)
        commands_list.append({
            "from": path[i],
            "to": path[i+1],
            "commands": commands
        })

    return commands_list

# --------------------- Generate Flattened Dubins Commands --------------------- #
def flattened_dubins_commands(path, goals, R, pause_ms=0):
    all_commands = []

    for i in range(len(path) - 1):
        q0 = goals[path[i]]
        q1 = goals[path[i+1]]
        
        edge = dubins_path_valid(q0, q1, R, OBSTACLES)
        
        if edge is None:
            raise RuntimeError(f"No valid Dubins path between {q0} and {q1}")
    
        path_type, segments, _ = edge
        commands = segments_to_commands(path_type, segments, R)

        all_commands.extend(commands)

        # Add pause after completing this Dubins segment
        if pause_ms > 0:
            all_commands.append(("Pu", pause_ms))

    return all_commands


# --------------------- Boundary-aware goal validation --------------------- #
def validate_goals_within_bounds(goals):
    """Ensure all goal points are within the defined boundaries"""
    valid_goals = []
    for i, (x, y, theta) in enumerate(goals):
        if not within_bounds(x, y):
            print(f"Warning: Goal {i} at ({x}, {y}) is outside boundaries")
            # Adjust goal to be within bounds
            x = max(X_MIN + 50, min(X_MAX - 50, x))
            y = max(Y_MIN + 50, min(Y_MAX - 50, y))
            print(f"  Adjusted to ({x}, {y})")
        valid_goals.append((x, y, theta))
    return valid_goals

# --------------------- Example Run --------------------- #
START_POSE = (150, 150, 0.0)   
obstacle_points = [
    (600, 600, "S"),
    (1200, 1200, "N"),
    (1700, 600, "W")
]

OBSTACLES = build_obstacles(obstacle_points)
goals = [START_POSE] + points_to_goals(obstacle_points)
start = 0
goals = validate_goals_within_bounds(goals)  # Validate and adjust if needed
radius = 100
edge_cache.clear()
unimproved_path = nearest_neighbour_optimized(start, goals, radius)
path = improve_path(unimproved_path, goals, radius)

full_commands = flattened_dubins_commands(path, goals, radius, pause_ms = 3000)

# Print sequential commands for the entire tour
print("Full sequential Dubins commands:")
for cmd in full_commands:
    print(cmd)

# Print boundary information
print(f"\nBoundaries: X=[{X_MIN}, {X_MAX}], Y=[{Y_MIN}, {Y_MAX}]")
print(f"All generated paths should stay within these boundaries.")
