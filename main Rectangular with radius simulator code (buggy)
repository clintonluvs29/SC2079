import math
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# --------------------- Constants --------------------- #
X_MIN, X_MAX = 0.0, 2000.0
Y_MIN, Y_MAX = 0.0, 2000.0
edge_cache = {}

# --------------------- Utility Functions --------------------- #
def normalize_to_90(theta):
    # Convert radians to nearest multiple of 90°
    deg = round(math.degrees(theta) / 90) * 90
    return math.radians(deg % 360)

def mod2pi(theta):
    return theta - 2.0 * math.pi * math.floor(theta / (2.0 * math.pi))

def euclidean(p, q):
    return math.hypot(p[0] - q[0], p[1] - q[1])

def within_bounds(x, y):
    """Check if a point is within the defined boundaries"""
    return X_MIN <= x <= X_MAX and Y_MIN <= y <= Y_MAX

# --------------------- Obstacles --------------------- #
def build_obstacles(obstacle_points):
    obstacles = []
    for x, y, _ in obstacle_points:
        obstacles.append((x-150, x+150, y-150, y+150))
    return obstacles

def point_in_rect(x, y, rect):
    xmin, xmax, ymin, ymax = rect
    return xmin <= x <= xmax and ymin <= y <= ymax

def path_collides(points, obstacles):
    for x, y, theta in points:
        for obs in obstacles:
            if point_in_rect(x, y, obs):
                return True
    return False

def path_out_of_bounds(points):
    for x, y, theta in points:
        if not within_bounds(x, y):
            return True
    return False

def right_angle_path(q0, q1, obstacles, turn_radius):
    def attempt_path(order):
        x0, y0, theta0 = q0
        x1, y1, theta1 = q1
    
        theta = normalize_to_90(theta0)
        x, y = x0, y0
    
        commands = []
        samples = [(x, y, theta)]
    
        def turn_to(target_theta):
            nonlocal theta, x, y
            target_theta = normalize_to_90(target_theta)
            diff = (target_theta - theta) % (2 * math.pi)
            if abs(diff) < 1e-9 or abs(diff - 2 * math.pi) < 1e-9:
                return
            if abs(diff - math.pi) < 1e-9:
                mid_theta = normalize_to_90(theta + math.pi / 2)
                turn_to(mid_theta)
                turn_to(target_theta)
                return
            if diff <= math.pi:
                sign, angle = 1.0, diff
            else:
                sign, angle = -1.0, 2 * math.pi - diff
            cx = x + turn_radius * math.cos(theta + sign * math.pi / 2)
            cy = y + turn_radius * math.sin(theta + sign * math.pi / 2)
            end_theta = theta + sign * angle
            x = cx - turn_radius * math.cos(end_theta + sign * math.pi / 2)
            y = cy - turn_radius * math.sin(end_theta + sign * math.pi / 2)
            theta = normalize_to_90(end_theta)
            commands.append(("LEFT" if sign > 0 else "RIGHT", math.degrees(angle)))
            samples.append((x, y, theta))
    
        def forward_by(dist, heading):
            nonlocal x, y
            if dist < 1e-6:
                return
            commands.append(("FORWARD", dist))
            x += dist * math.cos(heading)
            y += dist * math.sin(heading)
            samples.append((x, y, theta))
    
        def arc_displacement(from_theta, to_theta):
            """Returns (dx, dy) that turn_to will add to position."""
            from_theta = normalize_to_90(from_theta)
            to_theta = normalize_to_90(to_theta)
            diff = (to_theta - from_theta) % (2 * math.pi)
            if abs(diff) < 1e-9 or abs(diff - 2 * math.pi) < 1e-9:
                return 0.0, 0.0
            if abs(diff - math.pi) < 1e-9:
                # Two 90° left turns
                dx1, dy1 = arc_displacement(from_theta, normalize_to_90(from_theta + math.pi/2))
                mid = normalize_to_90(from_theta + math.pi/2)
                dx2, dy2 = arc_displacement(mid, to_theta)
                return dx1 + dx2, dy1 + dy2
            if diff <= math.pi:
                sign, angle = 1.0, diff
            else:
                sign, angle = -1.0, 2 * math.pi - diff
            # Center offset from current pos
            cx_off = turn_radius * math.cos(from_theta + sign * math.pi / 2)
            cy_off = turn_radius * math.sin(from_theta + sign * math.pi / 2)
            end_theta = from_theta + sign * angle
            ex_off = cx_off - turn_radius * math.cos(end_theta + sign * math.pi / 2)
            ey_off = cy_off - turn_radius * math.sin(end_theta + sign * math.pi / 2)
            return ex_off, ey_off
    
        # ---- Compute headings and segment lengths ----
        if order == ["X", "Y"]:
            heading1 = 0.0 if x1 > x0 else math.pi
            heading2 = math.pi / 2 if y1 > y0 else 3 * math.pi / 2
        else:
            heading1 = math.pi / 2 if y1 > y0 else 3 * math.pi / 2
            heading2 = 0.0 if x1 > x0 else math.pi
    
        heading_final = normalize_to_90(theta1)
    
        # Compute how much each turn displaces the robot
        dx_t0, dy_t0 = arc_displacement(theta, heading1)        # initial turn
        dx_t1, dy_t1 = arc_displacement(heading1, heading2)     # corner turn
        dx_t2, dy_t2 = arc_displacement(heading2, heading_final) # final turn
    
        # After initial turn, robot is at (x0+dx_t0, y0+dy_t0)
        # seg1 drives along heading1, then corner turn adds (dx_t1, dy_t1)
        # seg2 drives along heading2, then final turn adds (dx_t2, dy_t2)
        # We need robot to end at (x1, y1) after final turn
    
        # Along heading1 axis: start_pos + dx_t0 + seg1 + dx_t1 + dx_t2 = x1 (for X,Y order)
        # Along heading2 axis: start_pos + dy_t0 + dy_t1 + seg2 + dy_t2 = y1
    
        if order == ["X", "Y"]:
            seg1 = (x1 - x0) - dx_t0 - dx_t1
            seg2 = (y1 - y0) - dy_t0 - dy_t1 - dy_t2
        else:
            seg1 = (y1 - y0) - dy_t0 - dy_t1
            seg2 = (x1 - x0) - dx_t0 - dx_t1 - dx_t2
    
        if seg1 < -1e-6 or seg2 < -1e-6:
            return None  # not enough room for turns
    
        # ---- Execute ----
        needs_seg1 = abs(x1 - x0) > 1e-6 if order == ["X", "Y"] else abs(y1 - y0) > 1e-6
        needs_seg2 = abs(y1 - y0) > 1e-6 if order == ["X", "Y"] else abs(x1 - x0) > 1e-6
    
        turn_to(heading1)
        if needs_seg1:
            forward_by(seg1, heading1)
    
        if needs_seg1 and needs_seg2:
            turn_to(heading2)
    
        if needs_seg2:
            if not needs_seg1:
                turn_to(heading2)
            forward_by(seg2, heading2)
    
        turn_to(heading_final)
    
        if path_collides(samples, obstacles):
            return None
        if path_out_of_bounds(samples):
            return None
    
        total_length = sum(cmd[1] for cmd in commands if cmd[0] == "FORWARD")
        return commands, total_length

    # Try both L-shapes
    path_xy = attempt_path(["X", "Y"])
    path_yx = attempt_path(["Y", "X"])

    valid_paths = [p for p in [path_xy, path_yx] if p is not None]
    if not valid_paths:
        return None

    return min(valid_paths, key=lambda p: p[1])

# --------------------- TSP Heuristics --------------------- #
def get_edge(i, j, goals, R, edge_cache):
    if (i, j) in edge_cache:
        return edge_cache[(i, j)]

    result = right_angle_path(goals[i], goals[j], OBSTACLES, R)

    edge_cache[(i, j)] = result
    return result

def nearest_neighbour_optimized(start, points, R):
    n = len(points)
    visited = [False] * n
    path = [start]
    visited[start] = True
    v = start
    for _ in range(n - 1):
        candidates = [(euclidean(points[v], points[w]), w) for w in range(n) if not visited[w]]
        candidates.sort(key=lambda x: x[0])
        best_dubins = float('inf')
        best_w = None

        for e_dist, w in candidates:
            if e_dist >= best_dubins:
                break
            edge = get_edge(v, w, points, R, edge_cache)
            if edge is None:
                continue
            d_dist = edge[1]
            if d_dist < best_dubins:
                best_dubins = d_dist
                best_w = w

        if best_w is None:
            raise RuntimeError(f"No valid Dubins edge from node {v} (collision or out of bounds)")

        path.append(best_w)
        visited[best_w] = True
        v = best_w
    return path

def swap(path, i, j):
    path[i], path[j] = path[j], path[i]

def path_length(path, points, R):
    total = 0.0
    for i in range(len(path)-1):
        edge = get_edge(path[i], path[i+1], goals, R, edge_cache)
        if edge is None:
            return float("inf")
        total += edge[1]
    return total

def improve_path(path, points, R):
    best_length = path_length(path, points, R)
    for i in range(1, len(path)-1):
        swap(path, i, i+1)
        new_length = path_length(path, points, R)
        if new_length >= best_length:
            swap(path, i, i+1)
        else:
            best_length = new_length
    return path

def points_to_goals(points):
    goals = []
    for x, y, direction in points:
        if direction == "N":
            goal = (x, y + 300, 3 * math.pi / 2)   # goal is North, robot faces South
        elif direction == "S":
            goal = (x, y - 300, math.pi / 2)        # goal is South, robot faces North
        elif direction == "W":
            goal = (x - 300, y, 0.0)                # goal is West, robot faces East
        elif direction == "E":
            goal = (x + 300, y, math.pi)            # goal is East, robot faces West
        else:
            raise ValueError(f"Unknown direction: {direction}")
        goals.append(goal)
    return goals

# --------------------- Example Run --------------------- 
START_POSE = (150, 150, math.pi/2)   
obstacle_points = [
    (500, 500, "E"),   # Right / East
    (1500, 1500, "W"), # Left / West
    (500, 1500, "S"),
    (400, 700, "E"),
    (1750, 1000, "W")
]

OBSTACLES = build_obstacles(obstacle_points)
goals = [START_POSE] + points_to_goals(obstacle_points)
start = 0
radius = 50
edge_cache.clear()
unimproved_path = nearest_neighbour_optimized(start, goals, radius)
path = improve_path(unimproved_path, goals, radius)

full_commands = []

for i in range(len(path) - 1):
    edge = get_edge(path[i], path[i+1], goals, radius, edge_cache)

    if edge is None:
        raise RuntimeError("Invalid edge in final tour")

    commands, _ = edge
    full_commands.extend(commands)

    # Add pause after reaching each goal (except final goal if you prefer)
    full_commands.append(("PAUSE", 3000))

# Print sequential commands for the entire tour
print("Full sequential commands:")
for cmd in full_commands:
    print(cmd)
