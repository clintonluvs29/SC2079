import math

def mod2pi(theta):
    return theta - 2.0 * math.pi * math.floor(theta / (2.0 * math.pi))

def LSL(alpha, beta, d):
    tmp = d + math.sin(alpha) - math.sin(beta)
    p_sq = 2 + d*d - 2*math.cos(alpha - beta) + 2*d*(math.sin(alpha) - math.sin(beta))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    t = mod2pi(-alpha + math.atan2((math.cos(beta) - math.cos(alpha)), tmp))
    q = mod2pi(beta - math.atan2((math.cos(beta) - math.cos(alpha)), tmp))
    return t + p + q

def RSR(alpha, beta, d):
    tmp = d - math.sin(alpha) + math.sin(beta)
    p_sq = 2 + d*d - 2*math.cos(alpha - beta) + 2*d*(math.sin(beta) - math.sin(alpha))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    t = mod2pi(alpha - math.atan2((math.cos(alpha) - math.cos(beta)), tmp))
    q = mod2pi(-beta + math.atan2((math.cos(alpha) - math.cos(beta)), tmp))
    return t + p + q

def LSR(alpha, beta, d):
    p_sq = -2 + d*d + 2*math.cos(alpha - beta) + 2*d*(math.sin(alpha) + math.sin(beta))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    tmp = math.atan2(-math.cos(alpha) - math.cos(beta),
                     d + math.sin(alpha) + math.sin(beta))
    t = mod2pi(-alpha + tmp)
    q = mod2pi(-beta + tmp)
    return t + p + q

def RSL(alpha, beta, d):
    p_sq = -2 + d*d + 2*math.cos(alpha - beta) - 2*d*(math.sin(alpha) + math.sin(beta))
    if p_sq < 0:
        return None
    p = math.sqrt(p_sq)
    tmp = math.atan2(math.cos(alpha) + math.cos(beta),
                     d - math.sin(alpha) - math.sin(beta))
    t = mod2pi(alpha - tmp)
    q = mod2pi(beta - tmp)
    return t + p + q

def RLR(alpha, beta, d):
    tmp = (6 - d*d + 2*math.cos(alpha - beta) +
           2*d*(math.sin(alpha) - math.sin(beta))) / 8
    if abs(tmp) > 1:
        return None
    p = mod2pi(2*math.pi - math.acos(tmp))
    t = mod2pi(alpha - math.atan2(math.cos(alpha) - math.cos(beta),
                                  d - math.sin(alpha) + math.sin(beta)) + p/2)
    q = mod2pi(alpha - beta - t + p)
    return t + p + q

def LRL(alpha, beta, d):
    tmp = (6 - d*d + 2*math.cos(alpha - beta) +
           2*d*(math.sin(beta) - math.sin(alpha))) / 8
    if abs(tmp) > 1:
        return None
    p = mod2pi(2*math.pi - math.acos(tmp))
    t = mod2pi(-alpha - math.atan2(math.cos(alpha) - math.cos(beta),
                                   d + math.sin(alpha) - math.sin(beta)) + p/2)
    q = mod2pi(beta - alpha - t + p)
    return t + p + q

def dubins_distance(q0, q1, R):
    """
    q0, q1 = (x, y, theta)
    R = minimum turning radius
    """
    dx = q1[0] - q0[0]
    dy = q1[1] - q0[1]
    D = math.hypot(dx, dy)
    d = D / R

    theta = math.atan2(dy, dx)
    alpha = mod2pi(q0[2] - theta)
    beta  = mod2pi(q1[2] - theta)

    paths = [
        LSL(alpha, beta, d),
        RSR(alpha, beta, d),
        LSR(alpha, beta, d),
        RSL(alpha, beta, d),
        RLR(alpha, beta, d),
        LRL(alpha, beta, d),
    ]

    valid_paths = [p for p in paths if p is not None]

    return min(valid_paths) * R
